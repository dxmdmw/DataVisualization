正则表达式是处理字符串的强大工具，它有自己特定的语法结构，有了它，实现字符串的检索、替换、匹配验证都不在话下。

当然，对于爬虫来说，有了它，从HTML里提取想要的信息就非常方便了。

1. 实例引入

打开开源中国提供的正则表达式测试工具 http://tool.oschina.net/regex/， 输入待匹配的文本，然后选择常用的正则表达式，就可以得出相应的匹配结果了。例如，这里输入待匹配的文本如下：

```
Hello, my phone number is 010-86432100 and email is cqc@cuiqingcai.com, and my website is http://cuiqingcai.com.
1
Hello, my phone number is 010-86432100 and email is cqc@cuiqingcai.com, and my website is http://cuiqingcai.com.
```
这段字符串中包含了一个电话号码和一个电子邮件，接下来就尝试用正则表达式提取出来，如图3-10所示。

图3-10 运行页面

在网页右侧选择“匹配Email地址”，就可以看到下方出现了文本中的E-mail。如果选择“匹配网址URL”，就可以看到下方出现了文本中的URL。是不是非常神奇？

其实，这里就是用了正则表达式匹配，也就是用一定的规则将特定的文本提取出来。比如，电子邮件开头是一段字符串，然后是一个@符号，最后是某个域名，这是有特定的组成格式的。另外，对于URL，开头是协议类型，然后是冒号加双斜线，最后是域名加路径。

对于URL来说，可以用下面的正则表达式匹配：


[a-zA-z]+://[^\s]*
1
[a-zA-z]+://[^\s]*
用这个正则表达式去匹配一个字符串，如果这个字符串中包含类似URL的文本，那就会被提取出来。

这个正则表达式看上去是乱糟糟的一团，其实不然，这里面都是有特定的语法规则的。比如，a-z代表匹配任意的小写字母，\s表示匹配任意的空白字符，*就代表匹配前面的字符任意多个，这一长串的正则表达式就是这么多匹配规则的组合。

写好正则表达式后，就可以拿它去一个长字符串里匹配查找了。不论这个字符串里面有什么，只要符合我们写的规则，统统可以找出来。对于网页来说，如果想找出网页源代码里有多少URL，用匹配URL的正则表达式去匹配即可。

上面我们说了几个匹配规则，表3-2列出了常用的匹配规则。

表3-2 常用的匹配规则

模式

描述

\w

匹配字母、数字及下划线

\W

匹配不是字母、数字及下划线的字符

\s

匹配任意空白字符，等价于[\t\n\r\f]

\S

匹配任意非空字符

\d

匹配任意数字，等价于[0-9]

\D

匹配任意非数字的字符

\A

匹配字符串开头

\Z

匹配字符串结尾，如果存在换行，只匹配到换行前的结束字符串

\z

匹配字符串结尾，如果存在换行，同时还会匹配换行符

\G

匹配最后匹配完成的位置

\n

匹配一个换行符

\t

匹配一个制表符

^

匹配一行字符串的开头

$

匹配一行字符串的结尾

.

匹配任意字符，除了换行符，当re.DOTALL标记被指定时，则可以匹配包括换行符的任意字符

[...]

用来表示一组字符，单独列出，比如[amk]匹配a、m或k

[^...]

不在[]中的字符，比如[^abc]匹配除了a、b、c之外的字符

*

匹配0个或多个表达式

+

匹配1个或多个表达式

?

匹配0个或1个前面的正则表达式定义的片段，非贪婪方式

{n}

精确匹配n个前面的表达式

{n, m}

匹配n到m次由前面正则表达式定义的片段，贪婪方式

a|b

匹配a或b

( )

匹配括号内的表达式，也表示一个组

看完了之后，可能有点晕晕的吧，不过不用担心，后面我们会详细讲解一些常见规则的用法。

其实正则表达式不是Python独有的，它也可以用在其他编程语言中。但是Python的re库提供了整个正则表达式的实现，利用这个库，可以在Python中使用正则表达式。在Python中写正则表达式几乎都用这个库，下面就来了解它的一些常用方法。

2. match()
这里首先介绍第一个常用的匹配方法——match()，向它传入要匹配的字符串以及正则表达式，就可以检测这个正则表达式是否匹配字符串。

match()方法会尝试从字符串的起始位置匹配正则表达式，如果匹配，就返回匹配成功的结果；如果不匹配，就返回None。示例如下：

```
import re

content = 'Hello 123 4567 World_This is a Regex Demo'
print(len(content))
result = re.match('^Hello\s\d\d\d\s\d{4}\s\w{10}', content)
print(result)
print(result.group())
print(result.span())
1
2
3
4
5
6
7
8
import re
 
content = 'Hello 123 4567 World_This is a Regex Demo'
print(len(content))
result = re.match('^Hello\s\d\d\d\s\d{4}\s\w{10}', content)
print(result)
print(result.group())
print(result.span())
```
运行结果如下：

```
41
<_sre.SRE_Match object; span=(0, 25), match='Hello 123 4567 World_This'>
Hello 123 4567 World_This
(0, 25)
1
2
3
4
41
<_sre.SRE_Match object; span=(0, 25), match='Hello 123 4567 World_This'>
Hello 123 4567 World_This
(0, 25)
```
这里首先声明了一个字符串，其中包含英文字母、空白字符、数字等。接下来，我们写一个正则表达式：

```
^Hello\s\d\d\d\s\d{4}\s\w{10}
1
^Hello\s\d\d\d\s\d{4}\s\w{10}
```
用它来匹配这个长字符串。开头的^是匹配字符串的开头，也就是以Hello开头；然后\s匹配空白字符，用来匹配目标字符串的空格；\d匹配数字，3个\d匹配123；然后再写1个\s匹配空格；后面还有4567，我们其实可以依然用4个\d来匹配，但是这么写比较烦琐，所以后面可以跟{4}以代表匹配前面的规则4次，也就是匹配4个数字；然后后面再紧接1个空白字符，最后\w{10}
